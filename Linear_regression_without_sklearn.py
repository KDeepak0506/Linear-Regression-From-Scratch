# -*- coding: utf-8 -*-
"""Linear Regression without sklearn.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hRn1wS3d_t0Xc_PmpQs0eJYzQjmoQ4LR
"""

#importing libraries
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd

#importing the dataset
df=pd.read_csv("Housing.csv")
df

#visualizing the data
sns.scatterplot(data=df,x="area",y="price")
plt.title("House price vs area")
plt.show()

#prepocessing data
df.dropna()

#extacting the data
x=np.array(df["area"])
y=np.array(df["price"])

#normalization
def MinMaxScaling(x,y):
  y=(y-np.min(y))/(np.max(y)-np.min(y))
  x=(x-np.min(x))/(np.max(x)-np.min(x))
  return x,y

#model
def My_LinearRegression(x,y,epoch,learning_rate):
  #initialising
  weight=0
  bias=0
  n=x.size
  loss=[]
  #training with Gradient descent
  for i in range(epoch):
    y_pred=(weight*x) + bias
    diff=y-y_pred
    mse=np.mean(diff**2)    #Calculating the Mean Square Error
    loss.append(mse)
    dw=(-2/n)*np.sum(diff*x)
    db=(-2/n)*np.sum(diff)
    weight-=learning_rate*dw    #Updating the Weight and Bias with Gradient
    bias-=learning_rate*db
    if mse < 1e-6:
      print(f"Early stopping at epoch {i} with MSE {mse}")
      break
  #plotting
  plt.plot(loss)
  plt.xlabel("epoch")
  plt.ylabel("Mean square error")
  plt.show()

  return weight,bias,y_pred

#normalize
x,y=MinMaxScaling(x,y)
weight,bias,y_pred=My_LinearRegression(x,y,100000,0.0001)

#For Comparing My Linear Regression Model with that of Sklearn Library
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split

# Reshape x and y to be 2D and Fitting the Data in Sklearn Model
def sklearn_LR(x,y):
  x_2d = x.reshape(-1, 1)
  y_2d = y.reshape(-1, 1)
  model_sklearn = LinearRegression()
  model_sklearn.fit(x_2d, y_2d)
  y_pred_sklearn = model_sklearn.predict(x_2d)
  y_flat=y_pred_sklearn.flatten()

  return y_flat,x_2d,model_sklearn
y_flat,x_2d,model_sklearn=sklearn_LR(x,y)

#Comparison of Both Models with Graph
def plot_cmp(x,y,y_flat,y_pred):
  sns.lineplot(x=x,y=y_flat,color="green",label="sklearn_model")
  sns.lineplot(x=x,y=y_pred,color="black",label="my_model")
  sns.scatterplot(x=x,y=y,color="crimson",label="data")
  plt.legend()
  plt.show()
plot_cmp(x,y,y_flat,y_pred)

#Comparison of Both Models through MSE
from sklearn.metrics import mean_squared_error
def Model_accuracy(y,y_pred,x_2d,model_sklearn):
  mse_sklearn = mean_squared_error(y, model_sklearn.predict(x_2d))
  mse_custom = mean_squared_error(y, y_pred)

  print(f"Sklearn MSE: {mse_sklearn:.4f}")
  print(f"Custom Model MSE: {mse_custom:.4f}")

Model_accuracy(y,y_pred,x_2d,model_sklearn)

#Importing diff Dataset for Model comparison
df1=pd.read_csv("advertising.csv")
df1

#Plotting the data
sns.scatterplot(data=df1,x="TV",y="Sales")
plt.title("Sales vs TV")
plt.show()

#Same Preprocessing and data Extraction
df1.dropna()
X=np.array(df1["TV"])
Y=np.array(df1["Sales"])

#Normalisation and Model Training
X,Y=MinMaxScaling(X,Y)
Weights,Bias,Y_pred=My_LinearRegression(X,Y,100000,0.0001)
Y_flat,X_2d,Model_sklearn=sklearn_LR(X,Y)
plot_cmp(X,Y,Y_flat,Y_pred)

Model_accuracy(Y,Y_pred,X_2d,Model_sklearn)

